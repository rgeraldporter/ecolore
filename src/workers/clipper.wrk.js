const fs = require('fs-extra');
const R = require('ramda');
const sox = require('sox.js');
const ffmpeg = require('ffmpeg-static');
const Future = require('fluture');
const https = require('https');
const { Maybe } = require('simple-maybe');
const util = require('util');
const exec = util.promisify(require('child_process').exec);
const request = require('request');
const db = require('../models/index');
const moment = require('moment');
const flatten = require('array-flatten');

const minFrequencyBandwidth = 4000;
const durationPadding = 2;
const cuePadding = 1;
const getFrequencyCeiling = ({ frequencyCeiling, frequencyFloor }) =>
    frequencyCeiling - frequencyFloor < minFrequencyBandwidth
        ? frequencyFloor + minFrequencyBandwidth
        : frequencyCeiling;

const findAllAcousticFiles = Future.encaseP(a => db.AcousticFile.findAll(a));
const findAllObservations = Future.encaseP(a => db.Observation.findAll(a));
const updateAcousticFile = Future.encaseP(([a, b]) =>
    db.AcousticFile.update(a, b)
);
const createLog = Future.encaseP(a => db.Log.create(a));

const trimmedString = ({ string, length }) =>
    string.length > length ? string.substring(0, length - 3) + '...' : string;

const getCue = start => (start - cuePadding < 0 ? 0 : start - cuePadding);

const fileNameToDateTime = ({ filename, seconds }) => {
    const datestring = filename.slice(0, -4);
    return moment(
        filename.split('_')[1] + datestring.split('_')[2],
        'YYYYMMDDHHmmss'
    )
        .add(seconds, 'seconds')
        .format('YYYY-MM-DD HH:mm:ss');
};

const download = ({ url, dest, cb }) => {
    request.head(url, (err, res, body) => {
        console.log('content-type:', res.headers['content-type']);
        console.log('content-length:', res.headers['content-length']);

        request(url)
            .pipe(fs.createWriteStream(dest))
            .on('close', cb);
    });
};

const getTempPath = () => `${__dirname}/../../temp`;

const getFilePath = filename => `${getTempPath()}/${filename}`;

const clipFile = ({
    filename,
    start,
    duration,
    clipName,
    callback,
    frequencyFloor,
    frequencyCeiling,
    id,
    labelText
}) => {
    sox(
        {
            inputFile: `${getTempPath()}/${filename}.flac`,
            outputFile: `${getTempPath()}/${clipName}.flac`,
            effects: ['trim', getCue(start), duration + durationPadding]
        },
        () => {
            sox(
                {
                    inputFile: `${getTempPath()}/${clipName}.flac`,
                    effects: [
                        'rate',
                        '22k',
                        'spectrogram',
                        '-o',
                        `${getTempPath()}/${clipName}-spectrogram.png`,
                        '-t',
                        `${fileNameToDateTime({
                            filename,
                            seconds: getCue(start)
                        })} "${trimmedString({
                            string: labelText,
                            length: 36
                        })}" (Hamilton Bioacoustic Research Project, Observation #${id})`,
                        '-w',
                        'kaiser',
                        '-c',
                        `[generated by ecolore.org]`,
                        '-W',
                        '10',
                        '-Z',
                        '30'
                    ]
                },
                () => {
                    const ffmpegPath = ffmpeg.path;
                    exec(
                        `${ffmpegPath} -i ${getTempPath()}/${clipName}.flac -y -lavfi showspectrumpic=start=${frequencyFloor}:stop=${getFrequencyCeiling(
                            { frequencyCeiling, frequencyFloor }
                        ) *
                            1.5}:s=800x600:color=6:gain=0.25 ${getTempPath()}/${clipName}-focused-spectrogram.png`
                    ).then(callback);
                }
            );
        }
    );
};

const getFilenameFromObservation = R.path(['data', 'filename']);

const checkIfFileExists = filename =>
    fs.existsSync(getFilePath(filename + '.flac'));

const clipAudioFile = ({ fileUrl, observation }, callback) =>
    Maybe.of(checkIfFileExists(getFilenameFromObservation(observation))).fork(
        _ => console.error('Error occurred!'),
        fileExists => {
            console.log('taking on', observation);
            return fileExists
                ? clipFile({
                      filename: getFilenameFromObservation(observation),
                      id: observation.id,
                      labelText: observation.data.labelText,
                      start: Math.floor(observation.data.startTime),
                      duration: Math.ceil(observation.data.duration),
                      clipName: `hamont-bioacoustic-observation-${
                          observation.id
                      }`,
                      frequencyCeiling: Math.ceil(
                          observation.data.frequencyCeiling
                      ),
                      frequencyFloor: Math.floor(
                          observation.data.frequencyFloor
                      ),
                      callback
                  })
                : download({
                      url: `${
                          observation.surveyUrl
                      }${getFilenameFromObservation(observation)}.flac`,
                      dest: `${getTempPath()}/${getFilenameFromObservation(
                          observation
                      )}.flac`,
                      cb: () =>
                          clipFile({
                              filename: getFilenameFromObservation(observation),
                              id: observation.id,
                              labelText: observation.data.labelText,
                              start: Math.floor(observation.data.startTime),
                              duration: Math.ceil(observation.data.duration),
                              clipName: `hamont-bioacoustic-observation-${
                                  observation.id
                              }`,
                              frequencyCeiling: Math.ceil(
                                  observation.data.frequencyCeiling
                              ),
                              frequencyFloor: Math.floor(
                                  observation.data.frequencyFloor
                              ),
                              callback
                          })
                  });
        }
    );

/*
 1. get list of files without derive data log
 2. start at top, find observations with that file
 3. clip the audios
*/

const getObservationsFromFile = file =>
    findAllObservations({
        where: {
            data: {
                filename: file
            }
        },
        include: [db.Survey]
    });

const clipAudioFileF = Future.encaseN(clipAudioFile);

const flagAcousticFile = (file, callback) => {
    return updateAcousticFile([
        {
            data: Object.assign(file.get('data'), { derived: { clips: true } })
        },
        {
            where: {
                id: file.get('id')
            }
        }
    ]);
};

const getAcousticFiles = callback =>
    findAllAcousticFiles({
        where: db.Sequelize.literal(
            "json_unquote(json_extract(`AcousticFile`.`data`,'$.derived.clip')) IS NULL"
        )
    })
        .chain(files => {
            const collectObservations = () =>
                files.map(file =>
                    getObservationsFromFile(file.get('name')).chain(
                        observations => {
                            return flagAcousticFile(file).map(
                                () => observations
                            );
                        }
                    )
                );
            return Future.parallel(1, collectObservations());
        })
        .chain(observationsCollection => {
            const observations = flatten(observationsCollection);
            const deriveClips = () =>
                observations.map(observation => {
                    if (!observation.Survey) {
                        return Future.of(null);
                    }
                    return Future((reject, resolve) => {
                        clipAudioFile(
                            {
                                observation: {
                                    data: observation.data,
                                    id: observation.id,
                                    surveyUrl:
                                        JSON.parse(
                                            observation.Survey.get('data')
                                        ).archive_org_url.replace(
                                            '/details/',
                                            '/download/'
                                        ) + '/'
                                }
                            },
                            () => {
                                createLog({
                                    level: 0,
                                    text: `Created clips for Obs #${
                                        observation.id
                                    }`,
                                    data: {
                                        observation: {
                                            data: observation.data,
                                            id: observation.id,
                                            surveyUrl:
                                                JSON.parse(
                                                    observation.Survey.get(
                                                        'data'
                                                    )
                                                ).archive_org_url.replace(
                                                    '/details/',
                                                    '/download/'
                                                ) + '/'
                                        }
                                    }
                                }).fork(console.error, resolve);
                            }
                        );
                    });
                });
            return Future.parallel(1, deriveClips());
        })
        .fork(console.error, res => {
            console.log('res', res);
            callback();
        });

module.exports = {
    clipAudioFile,
    getAcousticFiles
};
